# bcp-types

<span class="badge badge-green">Complete</span> <span class="badge badge-blue">Phase 1</span>

> The semantic vocabulary of BCP. Defines what kinds of context exist, how they are structured, and how their fields are serialized to and from bytes.

## Crate Info

| Field | Value |
|-------|-------|
| Path | `crates/bcp-types/` |
| Spec | [SPEC_02](block-type-definitions.md) |
| Dependencies | `bcp-wire`, `thiserror` |
| Dependents | `bcp-encoder`, `bcp-decoder` |

---

## Purpose and Role in the Protocol

The core insight of BCP is that LLM context is not unstructured text — it has semantic types. A code file is not the same as a conversation turn, which is not the same as a tool result. The RFC (Section 4.4) defines 11 semantic block types that capture the kinds of context an LLM actually consumes:

- **Code**: source files with language and path metadata
- **Conversation**: chat turns with role information
- **File trees**: directory structures for spatial awareness
- **Tool results**: output from MCP servers, LSP, grep, test runners
- **Documents**: prose, README files, wiki pages
- **Structured data**: JSON configs, YAML manifests, CSV tables
- **Diffs**: code changes with hunks for review
- **Annotations**: metadata overlays (priority hints, summaries, tags)
- **Embedding references**: links to vector stores
- **Images**: visual content with alt text
- **Extensions**: user-defined blocks for custom use cases

`bcp-types` is where all of these types live as Rust structs and enums. It is a **pure data definition layer** — it defines how block fields are structured and how they serialize to/from TLV-encoded bytes, but it does not own the block frame envelope (that's `bcp-wire`) or the payload-level encode/decode orchestration (that's `bcp-encoder`/`bcp-decoder`).

This separation matters because the same type definitions are shared by both the encoder and decoder. When `bcp-encoder` calls `BlockContent::encode_body()`, it gets the TLV bytes for a block. When `bcp-decoder` calls `BlockContent::decode_body()`, it reconstructs the typed struct from those same bytes. The types crate is the single source of truth for the field layout of every block.

---

## TLV Field Encoding

This is the most important concept in `bcp-types`. Every block body is a sequence of TLV (Tag-Length-Value) fields:

```
field_id (varint) | wire_type (varint) | payload
```

There are three wire types:

| Wire Type | ID | Payload | Use Case |
|-----------|----|---------|----------|
| **Varint** | 0 | Single varint value | Enum bytes, integer fields, flags |
| **Bytes** | 1 | Varint length + raw bytes | Strings, binary content, opaque data |
| **Nested** | 2 | Varint length + nested TLV | Repeated structs (FileEntry, DiffHunk) |

This design is deliberately protobuf-like for familiarity, but it serves a different purpose. In protobuf, TLV enables schema evolution for RPC messages. In BCP, it enables **forward compatibility for context blocks** — a newer encoder can add fields that an older decoder will skip without error, which is essential for a protocol that will evolve as LLM capabilities change.

### Forward Compatibility via Field Skipping

The `skip_field` function is the mechanism that enables forward compatibility:

```rust
pub fn skip_field(buf: &[u8], wire_type: FieldWireType) -> Result<usize, TypeError>;
```

When the decoder encounters a field_id it doesn't recognize, it reads the wire_type to determine how many bytes to skip:
- Varint: consume one varint value
- Bytes/Nested: read the length varint, skip that many bytes

This means a v1.1 encoder can add a `field_id=6` to CODE blocks (perhaps a `commit_hash`), and a v1.0 decoder will silently skip it and still decode the block correctly. No version negotiation required.

### Encoding and Decoding Helpers

The `fields.rs` module provides symmetric helper functions used by every block type:

```rust
// Encoding (used by encode_body)
pub fn encode_varint_field(buf: &mut Vec<u8>, field_id: u64, value: u64);
pub fn encode_bytes_field(buf: &mut Vec<u8>, field_id: u64, data: &[u8]);
pub fn encode_nested_field(buf: &mut Vec<u8>, field_id: u64, nested_data: &[u8]);

// Decoding (used by decode_body)
pub fn decode_field_header(buf: &[u8]) -> Result<(FieldHeader, usize), TypeError>;
pub fn decode_varint_value(buf: &[u8]) -> Result<(u64, usize), TypeError>;
pub fn decode_bytes_value(buf: &[u8]) -> Result<(&[u8], usize), TypeError>;
pub fn skip_field(buf: &[u8], wire_type: FieldWireType) -> Result<usize, TypeError>;
```

---

## Shared Enumerations

Every enumeration in the protocol uses a single-byte wire encoding for compactness — no strings, no multi-byte tags. This is a key token efficiency decision: a `Role::User` is 1 byte on the wire, not 4+ bytes for the string `"user"`.

Most enums are generated by a `wire_enum!` macro that eliminates boilerplate while keeping doc comments and derives explicit:

```rust
wire_enum! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq)]
    pub enum Role {
        System = 0x01,
        User = 0x02,
        Assistant = 0x03,
        Tool = 0x04,
    }
}
```

The macro generates `to_wire_byte()` and `from_wire_byte()` methods. `from_wire_byte` returns `Err(TypeError::InvalidEnumValue)` for unrecognized bytes, since most enums have fixed semantics (e.g. an unknown role would break conversation structure).

### Lang: The Exception

`Lang` is the one enum that **does not** use the macro. It has a special `Other(u8)` variant that preserves unrecognized language IDs rather than erroring:

```rust
pub fn from_wire_byte(value: u8) -> Self {
    match value {
        0x01 => Self::Rust,
        // ... known languages ...
        other => Self::Other(other),  // Forward compatible, not an error
    }
}
```

The rationale: new programming languages are added frequently, and a CODE block with an unknown language is still perfectly valid context. But an unknown conversation role would be semantically broken.

### Priority and the Token Budget Engine

The `Priority` enum implements `PartialOrd` + `Ord`:

```rust
assert!(Priority::Critical < Priority::High);
assert!(Priority::High < Priority::Normal);
```

This ordering is used by the token budget engine (SPEC_08, not yet implemented) to rank blocks during the two-pass decode: Critical blocks always get full content, Background blocks get a one-line reference, and everything in between is allocated proportionally.

---

## Block Type Structs

Each block type has a Rust struct with `encode_body()` and `decode_body()` methods. Here's how a typical block type works, using CODE as the example:

### CodeBlock Internals

```rust
pub struct CodeBlock {
    pub lang: Lang,
    pub path: String,
    pub content: Vec<u8>,
    pub line_range: Option<(u32, u32)>,
}
```

**Encoding** (`encode_body`): Writes TLV fields in order using the helpers from `fields.rs`. Optional fields are only written when present:

```rust
pub fn encode_body(&self) -> Vec<u8> {
    let mut buf = Vec::new();
    encode_varint_field(&mut buf, 1, u64::from(self.lang.to_wire_byte()));
    encode_bytes_field(&mut buf, 2, self.path.as_bytes());
    encode_bytes_field(&mut buf, 3, &self.content);
    if let Some((start, end)) = self.line_range {
        encode_varint_field(&mut buf, 4, u64::from(start));
        encode_varint_field(&mut buf, 5, u64::from(end));
    }
    buf
}
```

**Decoding** (`decode_body`): Iterates field headers in any order, matching on `field_id`. Unknown field IDs are skipped. At the end, required fields are validated:

```rust
pub fn decode_body(body: &[u8]) -> Result<Self, TypeError> {
    let mut lang = None;
    let mut path = None;
    let mut content = None;
    let mut line_start = None;
    let mut line_end = None;

    // Walk fields in any order
    while cursor < body.len() {
        let (header, n) = decode_field_header(&body[cursor..])?;
        cursor += n;
        match header.field_id {
            1 => { lang = Some(Lang::from_wire_byte(value as u8)); }
            2 => { path = Some(String::from_utf8_lossy(data).into()); }
            3 => { content = Some(data.to_vec()); }
            4 => { line_start = Some(value as u32); }
            5 => { line_end = Some(value as u32); }
            _ => { cursor += skip_field(...)?; }  // Forward compat
        }
    }

    // Validate required fields
    Ok(Self {
        lang: lang.ok_or(MissingRequiredField { ... })?,
        path: path.ok_or(MissingRequiredField { ... })?,
        content: content.ok_or(MissingRequiredField { ... })?,
        line_range: match (line_start, line_end) {
            (Some(s), Some(e)) => Some((s, e)),
            _ => None,
        },
    })
}
```

### Recursive Nested Types

`FileTreeBlock` and `DiffBlock` contain nested structures (`FileEntry`, `DiffHunk`) that are encoded as wire type 2 (Nested). The nested data is itself a sequence of TLV fields, pre-encoded by the caller. This enables recursive structures — a `FileEntry` with `kind=Directory` can contain child `FileEntry` values, each encoded as a nested field within the parent.

---

## Summary Sub-Block

The Summary is the mechanism that enables the token budget engine to substitute a compact description for a full block when context space is limited. Per RFC Section 7.1, a 500-line CODE file might have a 20-token summary instead of costing 800 tokens.

When `BlockFlags::HAS_SUMMARY` is set, the body begins with a length-prefixed summary before the TLV fields:

```
[varint] summary_len
[bytes]  summary_text (UTF-8, summary_len bytes)
[bytes]  remaining body (TLV fields)
```

```rust
pub struct Summary { pub text: String }

impl Summary {
    pub fn encode(&self, buf: &mut Vec<u8>);  // Appends to buffer
    pub fn decode(buf: &[u8]) -> Result<(Self, usize), TypeError>;  // Returns (summary, consumed)
}
```

---

## Unified Block and BlockContent

The top-level types that tie everything together:

```rust
pub struct Block {
    pub block_type: BlockType,
    pub flags: BlockFlags,
    pub summary: Option<Summary>,
    pub content: BlockContent,
}

pub enum BlockContent {
    Code(CodeBlock),
    Conversation(ConversationBlock),
    FileTree(FileTreeBlock),
    ToolResult(ToolResultBlock),
    Document(DocumentBlock),
    StructuredData(StructuredDataBlock),
    Diff(DiffBlock),
    Annotation(AnnotationBlock),
    EmbeddingRef(EmbeddingRefBlock),
    Image(ImageBlock),
    Extension(ExtensionBlock),
    End,
    Unknown { type_id: u8, body: Vec<u8> },
}
```

`BlockContent` provides the dispatch layer:
- `encode_body(&self) -> Vec<u8>` matches on the variant and delegates to the inner struct's `encode_body`
- `decode_body(block_type, body) -> Result<Self, TypeError>` matches on the `BlockType` and calls the appropriate struct's `decode_body`
- Unknown block types are captured as `Unknown { type_id, body }` — the raw bytes are preserved for potential round-tripping

---

## Error Types

```rust
pub enum TypeError {
    MissingRequiredField { block_type: &'static str, field_name: &'static str },
    UnknownFieldWireType { value: u64 },
    InvalidEnumValue { enum_name: &'static str, value: u8 },
    Wire(WireError),
}
```

---

## Module Map

```
src/
├── lib.rs              → #![warn(clippy::pedantic)], re-exports all public types
├── block_type.rs       → BlockType enum + wire_id/from_wire_id
├── enums.rs            → wire_enum! macro + Lang, Role, Status, Priority, etc.
├── fields.rs           → FieldWireType, encode/decode helpers, skip_field
├── summary.rs          → Summary encode/decode
├── block.rs            → Block, BlockContent unified types
├── code.rs             → CodeBlock (field IDs 1-5)
├── conversation.rs     → ConversationBlock (field IDs 1-3)
├── file_tree.rs        → FileTreeBlock, FileEntry, FileEntryKind (recursive nested)
├── tool_result.rs      → ToolResultBlock (field IDs 1-4)
├── document.rs         → DocumentBlock (field IDs 1-3)
├── structured_data.rs  → StructuredDataBlock (field IDs 1-3)
├── diff.rs             → DiffBlock, DiffHunk (nested, field IDs 1-3)
├── annotation.rs       → AnnotationBlock (field IDs 1-3)
├── embedding_ref.rs    → EmbeddingRefBlock (field IDs 1-3)
├── image.rs            → ImageBlock (field IDs 1-3)
├── extension.rs        → ExtensionBlock (field IDs 1-3)
├── end.rs              → EndBlock (no fields, empty body)
└── error.rs            → TypeError enum
```

## Build & Test

```bash
cargo build -p bcp-types
cargo test -p bcp-types
cargo clippy -p bcp-types -- -W clippy::pedantic
cargo doc -p bcp-types --no-deps
```
